theory Walk
  imports
    Multigraph
begin

type_synonym ('a, 'b) walk = "('a, 'b) edge list"

context other
begin

inductive walk :: "('a, 'b) multigraph \<Rightarrow> ('a, 'b) walk \<Rightarrow> 'b \<Rightarrow> 'b \<Rightarrow> bool" where
  walk_Nil: "v \<in> V G \<Longrightarrow> walk G [] v v" |
  walk_Cons: "\<lbrakk> e \<in> G; v \<in> endpoints e \<rbrakk> \<Longrightarrow> walk G [e] v (other e v)" |
  walk_Cons_Cons: "\<lbrakk> e \<in> G; u \<in> endpoints e; e' \<in> G; u \<in> endpoints e'; walk G (e' # es) u v \<rbrakk> \<Longrightarrow>
                   walk G (e # e' # es) (other e u) v"

inductive_simps walk_Nil_iff [simp]: "walk G [] u v"
inductive_simps walk_Cons_iff [simp]: "walk G [e] u v"
inductive_simps walk_Cons_Cons_iff [simp]: "walk G (e # e' # es) u v"

lemma walk_Cons_2:
  assumes "e \<in> G"
  assumes "v \<in> endpoints e"
  shows "walk G [e] (other e v) v"
proof -
  have "other e v \<in> endpoints e"
    using assms(2)
    by (fastforce dest: other)
  thus ?thesis
    using assms
    by (auto simp add: other_other_eq dest: walk_Cons)
qed

lemma walk_Cons_ConsE:
  assumes "walk G (e # e' # es) u v"
  obtains x where
    "other e x = u"
    "x \<in> endpoints e"
    "x \<in> endpoints e'"
    "walk G (e' # es) x v"
  using assms
  by auto

lemma walk_induct [case_names Nil Cons Cons_Cons]:
  assumes "P []"
  assumes "\<And>e. P [e]"
  assumes "\<And>e e' es. P (e' # es) \<Longrightarrow> P (e # e' # es)"
  shows "P p"
  using assms
  by (auto intro: induct_list012)

lemma walk_cases [case_names Nil Cons Cons_Cons]:
  assumes "P []"
  assumes "\<And>e. P [e]"
  assumes "\<And>e e' es. P (e # e' # es)"
  shows "P p"
  using assms
  by (auto intro: walk_induct)

lemma walk_tlI:
  assumes "walk G (e # es) u v"
  shows "walk G es (other e u) v"
  sorry

lemma set_walk_subset:
  assumes "walk G p u v"
  shows "set p \<subseteq> G"
  using assms
  by (induct arbitrary: u rule: walk_induct) auto

lemma hd_walk:
  assumes "walk G p u v"
  assumes "p \<noteq> []"
  shows "u \<in> endpoints (hd p)"
  using assms
proof (induct rule: walk_cases)
  case Nil
  thus ?case
    by blast
next
  case (Cons e)
  thus ?case
    by simp
next
  case (Cons_Cons e e' es)
  thus ?case
    by (fastforce dest: other elim: walk_Cons_ConsE)
qed

lemma hd_walk_2:
  assumes "walk G p u v"
  assumes "p \<noteq> []"
  shows "other (hd p) u \<in> endpoints (hd p)"
  using assms
  by (fastforce dest: hd_walk other)

fun walk_vertices :: "('a, 'b) walk \<Rightarrow> 'b \<Rightarrow> 'b list" where
  "walk_vertices [] v = [v]" |
  "walk_vertices (e # es) v = v # walk_vertices es (other e v)"

lemma endpoint_mem_set_walk_vertices:
  assumes "walk G p u v"
  assumes "e \<in> set p"
  assumes "x \<in> endpoints e"
  shows "x \<in> set (walk_vertices p u)"
  using assms
proof (induct arbitrary: u rule: walk_vertices.induct)
  case (1 v)
  thus ?case
    by force
next
  case (2 e es v)
  then show ?case sorry
qed

lemma set_walk_vertices_tl_subset:
  assumes "walk G (e # es) u v"
  shows "set (walk_vertices es (other e u)) \<subseteq> set (walk_vertices (e # es) u)"
  sorry

end

end